#!/usr/bin/env python
#-*- coding:utf-8 -*-

import argparse
import struct
import sys
import time

import poses

import rospy
import baxter_interface
from baxter_interface import CHECK_VERSION

from copy import deepcopy

from std_msgs.msg import Header

from geometry_msgs.msg import (
    PoseStamped,
    Pose,
    Point,
    Quaternion
)

from baxter_core_msgs.srv import (
    SolvePositionIK,
    SolvePositionIKRequest
)

class Arm(object):
    def __init__(self, limb, verbose=False):
        self._limb_name = limb
        self._verbose = verbose
        self._limb = baxter_interface.limb.Limb(limb)
        self._gripper = baxter_interface.Gripper(limb)
        self._gripper._type = self._gripper.type()
        self._ns = "ExternalTools/" + limb + "/PositionKinematicsNode/IKService"
        self._iksvc = rospy.ServiceProxy(self._ns, SolvePositionIK)
        self._ikreq = SolvePositionIKRequest()
        self._hdr = Header(stamp=rospy.Time.now(), frame_id='base')
        self._hover_distance = poses.hover_distance
        self._current_pose = self.get_current_pose()
        if self._gripper.type() is 'suction':
            self._gripper.set_vacuum_threshold(1.0)        
        
        if self._limb_name is 'left': 
            print("Getting robot state...")
            self._rs = baxter_interface.RobotEnable(baxter_interface.CHECK_VERSION)
            self._init_state = self._rs.state().enabled
            if not self._init_state:
                print("Enabling robot...")
                self._rs.enable()
            else:
                print("Robot already enabled...")
            if not self._gripper.calibrated():
                print("Calibrating left gripper...")
                self._gripper.calibrate()

    def get_solution(self, pose):
        if self._verbose: 
            print("--- func: get_solution ---")
            print("--- pose: ---")
            print(pose)
            print("------------------------")
        del self._ikreq.pose_stamp[:]
        self._ikreq.pose_stamp.append(PoseStamped(header=self._hdr, pose=pose))
        try:
            rospy.wait_for_service(self._ns, 5.0)
            resp = self._iksvc(self._ikreq)
        except (rospy.ServiceException, rospy.ROSException) as e:
            rospy.logerr("Service call failed: %s" %(e,))
            return 0

        #Check if result is valid, and type of seed ultimately used to get solution
        #convert rospy's string representation of uint8[]'s to int's
        resp_seeds = struct.unpack('<%dB' % len(resp.result_type), resp.result_type)
        if (resp_seeds[0] != resp.RESULT_INVALID):
            seed_str = {
                self._ikreq.SEED_USER: 'User Provided Seed',
                self._ikreq.SEED_CURRENT: 'Current Joint Angles',
                self._ikreq.SEED_NS_MAP : 'Nullspace Setpoints',
            }.get(resp_seeds[0], 'None')
            print("SUCCESS - Valid Joint Solution Found from Seed Type: %s" % (seed_str,))
            #Format solution into Limb API-compatible dictionary
            self._ik_solution = dict(zip(resp.joints[0].name, resp.joints[0].position))
            """ if self._verbose:
                print("\nIK Solution:\n", self._ik_solution)
                print("--------------------------")
                print("Response Message:\n", resp )"""
            return 1
        else:
            print ("INVALID POSE - No Valid Joint Solution Found.")
        return 0

    def move_to_solution(self):
        print("moving %s arm..." %self._limb_name)
        self._limb.move_to_joint_positions(self._ik_solution)
        self._current_pose = self.get_current_pose()

    def set_neutral(self, open_gripper=True):
        self._limb.move_to_neutral()
        if open_gripper:
            self._gripper.open()
        self._current_pose = self.get_current_pose()

    def get_current_pose(self):
        """gets the current pose of the calling limb as Pose"""
        current_pose = self._limb.endpoint_pose()
        ik_pose = Pose()
        ik_pose.position.x = current_pose['position'].x 
        ik_pose.position.y = current_pose['position'].y 
        ik_pose.position.z = current_pose['position'].z
        ik_pose.orientation.x = current_pose['orientation'].x 
        ik_pose.orientation.y = current_pose['orientation'].y 
        ik_pose.orientation.z = current_pose['orientation'].z 
        ik_pose.orientation.w = current_pose['orientation'].w
        if self._verbose: 
            print("--- func: get_current_pose ---")
            print("--- limb: {}_arm ---").format(self._limb_name)
            print("--- pose: ---")
            print(ik_pose)
            print("------------------------")
        return ik_pose

    def alter_pose_inc(self, pose, posx = 0.0, posy = 0.0, posz = 0.0, orx = 0.0, ory = 0.0, orz = 0.0, orw = 0.0):
        """changes the current pose with the given modifiers. the modifiers are defaulted to 0"""
        if self._verbose:
            print("--- func: alter_pose_inc ---")
            print("posx={} posy={} posz={} orx={} ory={} orz={} orw={}").format(posx, posy, posz, orx, ory, orz, orw) 
            print("--- given pose: ---")
            print(pose)
        pose.position.x += posx 
        pose.position.y += posy
        pose.position.z += posz
        pose.orientation.x += orx
        pose.orientation.y += ory
        pose.orientation.z += orz
        pose.orientation.w += orw
        if self._verbose:
            print("--- new pose: ---")
            print(pose)
            print("------------------------")
        return pose
    
    def alter_pose_abs(self, pose, posx = None, posy = None, posz = None, orx = None, ory = None, orz = None, orw = None):
        """changes the current pose with the given absolute values. the parameters are defaulted to self._current_pose"""
        if self._verbose:
            print("--- func: alter_pose_abs ---")
            print("posx={} posy={} posz={} orx={} ory={} orz={} orw={}").format(posx, posy, posz, orx, ory, orz, orw)
        if posx is None: posx = pose.position.x
        if posy is None: posy = pose.position.y
        if posz is None: posz = pose.position.z
        if orx is None: orx = pose.orientation.x
        if ory is None: ory = pose.orientation.y
        if orz is None: orz = pose.orientation.z
        if orw is None: orw = pose.orientation.w
        if self._verbose: 
            print("--- given pose: ---")
            print(pose)
        pose.position.x = posx
        pose.position.y = posy
        pose.position.z = posz
        pose.orientation.x = orx
        pose.orientation.y = ory
        pose.orientation.z = orz
        pose.orientation.w = orw
        if self._verbose:
            print("--- new pose: ---")
            print(pose)
            print("------------------------")
        return pose

    def make_at_pose(self, pose, cmd, opening = 0):
        """approaches target in a safe way, fulfills cmd and retreats"""
        """commands: pick, place"""
        if self._verbose: 
            print("--- func: make_at_pose ---")
            print("cmd={}").format(cmd)
            print("--- given pose: ---")
            print(pose)
        make_pose = pose
        safe_pose = self.alter_pose_inc(deepcopy(pose), posz = self._hover_distance)

        if cmd is 'pick':
            #hover point
            if self.get_solution(safe_pose):
                if self._verbose:
                    print("moving to hover pose...")
                self.move_to_solution()
            else:
                return False
            if self.get_solution(make_pose):
                if self._verbose:
                    print("approaching target...")
                self._limb.set_joint_position_speed(0.15)
                self.move_to_solution()
            else: 
                return False
            if self._gripper._type is 'electric':
                self._gripper.command_position(position=opening)
                if self._gripper.missed():
                    print("Gripping with {}_arm failed").format(self._limb_name)
                    return False
            elif self._gripper._type is 'suction':
                self._gripper.close(timeout = 1.0)
            else:
                print("\nCustom gripper type detected. Please change the grippers to the required hardware.\nRequired gripper hardware:\nLeft: Electric\nRight: Suction")
        elif cmd is 'place':
            drag_paper_pose = self.alter_pose_inc(deepcopy(safe_pose), posx=0.28, posy=0.02, posz=0.28, orx=90.0)
            if self.get_solution(drag_paper_pose):
                if self._verbose:
                    print("moving to hover pose...")
                self.move_to_solution()
            else: 
                return False
            self.alter_pose_abs(drag_paper_pose, posz=poses.table_height+0.01)
            self.alter_pose_inc(drag_paper_pose, posx=-0.02)
            if self.get_solution(drag_paper_pose):
                if self._verbose:
                    print("lowering paper...")
                self.move_to_solution()
            else: 
                return False
            self.alter_pose_inc(make_pose, posz=0.01)
            if self.get_solution(drag_paper_pose):
                if self._verbose:
                    print("dragging paper...")
                self.move_to_solution()
            else: 
                return False 
            self.alter_pose_inc(make_pose, posy=-0.005, posz=-0.01)
            if self.get_solution(make_pose):
                if self._verbose:
                    print("approaching target...")
                self.move_to_solution()
                self._gripper.open()
            else: 
                return False
        #retreat
        if self.get_solution(safe_pose):
            if self._verbose:
                print("retreating to safe position...")
            self.move_to_solution()
            if self._gripper._type is 'suction':
                print("----> suction: {}").format(self._gripper.vacuum_sensor())
                if not self._gripper.vacuum_sensor() > 8.0:
                        print("Gripping with {}_arm failed\nSuction: {}").format(self._limb_name, self._gripper.vacuum_sensor())
                        return False
            self._limb.set_joint_position_speed(0.3)
            return True
        else:
            return False



def main():
    try:

        paper = False
        # Argument Parsing
        arg_fmt = argparse.RawDescriptionHelpFormatter
        parser = argparse.ArgumentParser(formatter_class=arg_fmt, description=main.__doc__)

        parser.add_argument(
            '-v', '--verbose',
            action='store_const',
            const=True,
            default=False,
            help="displays debug information (default = False)"
        )
        args = parser.parse_args(rospy.myargv()[1:])

        # Init
        rospy.init_node("ik_move", anonymous=True)
        time.sleep(0.5)
        print("--- Ctrl-D stops the program ---")
        print("Init started...")
        left = Arm("left", args.verbose)
        right = Arm("right", args.verbose)
        print("Init finished...")

        #Movement
            
        print("---> Both: Moving to neutral position... <---")
        left.set_neutral()
        right.set_neutral()

        
        print("---> Right: Pick Paper... <---")
        make_pose = deepcopy(right._current_pose)
        #right.alter_pose_abs(make_pose, posx=0.5, posy = 0.0, posz = poses.table_height, orx=0.0, orz=0.0, orw=0.0)
        right.alter_pose_abs(make_pose, posy = -0.15, posz = poses.table_height, orx=0.0, orz=0.0, orw=0.0)
        right.alter_pose_inc(make_pose, posx = 0.01)
        if not right.make_at_pose(make_pose, 'pick'):
            left.set_neutral()
            right.set_neutral()
            left._rs.disable()
            return False

        print("---> Right: Place Paper... <---")
        right.alter_pose_abs(make_pose, posx=0.422, posy=0.137, orx=90)
        if not right.make_at_pose(make_pose, 'place'):
            left.set_neutral()
            right.set_neutral()
            left._rs.disable()
            return False
        
        print("---> Right: Moving to neutral position... <---")
        right.set_neutral()

        

        print("---> Ending with neutral position... <---")
        left.set_neutral()
        right.set_neutral()
        left._rs.disable()
              
        print("exec finished.")
    except rospy.ROSInterruptException as e:
        return e
    except KeyboardInterrupt as e:
        return e

if __name__ == '__main__':
    main()